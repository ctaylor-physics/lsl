"""
This module stores various functions that are needed for computing UV 
coverage and time delays.  The functions in the module:
  * compute the u, v, and w coordinates of all baselines defined by an array 
    of stands
  * compute the track through the uv-plane of a collection of baselines as 
    the Earth rotates.
    
.. versionchanged:: 0.4.0
    Removed function for dealing with meta-data (position, cable length, etc.) 
    for individual stands since these are wrapped in the new :mod:`lsl.common.stations`
    module.
    
.. versionchanged:: 1.0.0
    Generalized the compute_uvw() and compute_uv_track() functions.

.. versionchanged:: 2.0.1
    Added support for ephem.Angle, astropy.coordinates.Angle, and 
    astropy.coordinates.EarthLocation instances in the compute_uvw() and 
    compute_uv_track() functions.

.. versionchanged:: 3.0.0
    Removed compute_uv_track()
"""

import ephem
import numpy as np

from astropy import units as astrounits
from astropy.constants import c as speedOfLight
from astropy.time import Time as AstroTime
from astropy.coordinates import Angle as AstroAngle
from astropy.coordinates import EarthLocation, HADec, GCRS
from astropy.coordinates.matrix_utilities import rotation_matrix

from lsl import astro
from lsl.common.stations import lwa1

from lsl.misc import telemetry
telemetry.track_module()


__version__ = '0.8'
__all__ = ['get_baselines', 'baseline_to_antennas', 'antennas_to_baseline', 'compute_uvw']


speedOfLight = speedOfLight.to('m/s').value


def get_baselines(antennas, antennas2=None, include_auto=False, indicies=False):
    """
    Generate a list of two-element tuples that describe which antennae
    compose each of the output uvw triplets from compute_uvw/compute_uv_track.
    If the indicies keyword is set to True, the two-element tuples 
    contain the indicies of the stands array used, rather than the actual
    stand numbers.
    """

    if include_auto:
        offset = 0
    else:
        offset = 1

    out = []
    N = len(antennas)
    
    # If we don't have an antennas2 array, use antennas again
    if antennas2 is None:
        antennas2 = antennas
    
    for i in range(0, N-offset):
        for j in range(i+offset, N):
            if indicies:
                out.append( (i, j) )
            else:
                out.append( (antennas[i], antennas2[j]) )

    return out
    

def baseline_to_antennas(baseline, antennas, antennas2=None, baseline_list=None, include_auto=False, indicies=False):
    """
    Given a baseline number, a list of stands, and options of how the base-
    line listed was generated, convert the baseline number to antenna numbers.
    Alternatively, use a list of baselines instead of generating a new list.  
    This utility is useful for figuring out what antennae comprise a baseline.
    """
    
    # If we don't have an antennas2 array, use antennas again
    if antennas2 is None:
        antennas2 = antennas

    # Build up the list of baselines using the options provided
    if baseline_list is None:
        baseline_list = get_baselines(antennas, antennas2=antennas2, include_auto=include_auto, indicies=indicies)
    
    # Select the correct one and return based on the value of indicies
    i,j = baseline_list[baseline]
    return i,j


def antennas_to_baseline(ant1, ant2, antennas, antennas2=None, baseline_list=None, include_auto=False, indicies=False):
    """
    Given two antenna numbers, a list of stands, and options to how the base-
    line listed was generated, convert the antenna pair to  a baseline number. 
    This utility is useful for picking out a particular pair from a list of
    baselines.
    """
    
    # If we don't have an antennas2 array, use antennas again
    if antennas2 is None:
        antennas2 = antennas

    # Build up the list of baselines using the options provided
    if baseline_list is None:
        baseline_list = get_baselines(antennas, antennas2=antennas2, include_auto=include_auto, indicies=indicies)
    
    # Loop over the baselines until we find one that matches.  If we don't find 
    # one, return -1
    i = 0
    for baseline in baseline_list:
        if ant1 in baseline and ant2 in baseline:
            return i
        i = i + 1
        
    return -1


def compute_uvw(antennas, HA=0.0, dec=34.070, freq=49.0e6, site=lwa1, include_auto=False):
    """
    Compute the uvw converate of a baselines formed by a collection of 
    stands.  The coverage is computed at a given HA (in hours) and 
    declination (in degrees) for a given site.  The frequency provided 
    (in Hz) can either as a scalar or as a numpy array.  If more than one 
    frequency is given, the output is a three dimensional with dimensions 
    of baselines, uvw, and frequencies.
    
    .. versionchanged:: 0.4.0
        Switched over to passing in Antenna instances generated by the
        :mod:`lsl.common.station` module instead of a list of stand ID
        numbers.
        
    .. versionchanged:: 1.0.0
        Added a keyword (site) to specify the station used for the 
        observation.
        
    .. versionchanged:: 1.1.2
        Updated to work with lists in a transparent manner.
    
    .. versionchanged:: 2.0.1
        Added support for ephem.Angle and astropy.coordinates.Angle instances 
        for HA and dec.
        Added support for astropy.coordinates.EarthLocation instances for site.
    """
    
    # Try this so that freq can be either a scalar, a list, or an array
    try: 
        freq.size
        assert(freq.shape != ())
    except (AttributeError, AssertionError):
        freq = np.array(freq, ndmin=1)
        
    baselines = get_baselines(antennas, include_auto=include_auto, indicies=True)
    Nbase = len(baselines)
    Nfreq = freq.size
    uvw = np.zeros((Nbase,3,Nfreq))

    # Phase center coordinates
    # Convert numbers to radians and, for HA, hours to degrees
    if isinstance(HA, (astro.hms, astro.dms)):
        HA2 = HA.to_rad()
    elif isinstance(HA, AstroAngle):
        HA2 = HA.rad
    elif isinstance(HA, ephem.Angle):
        HA2 = HA*1.0
    else:
        HA2 = HA * 15.0 * np.pi/180
    if isinstance(dec, astro.dms):
        dec2 = dec.to_rad()
    elif isinstance(dec, AstroAngle):
        dec2 = dec.rad
    elif isinstance(dec, ephem.Angle):
        dec2 = dec*1.0
    else:
        dec2 = dec * np.pi/180
        
    # Setup - Target and antennas in ITRF
    try:
        t = AstroTime(site.date + astro.DJD_OFFSET, format='jd', scale='utc')
    except AttributeError:
        t = AstroTime.now()
    if isinstance(site, EarthLocation):
        el = site
    else:
        el = site.earth_location
    ha = HADec(HA2*astrounits.rad, dec2*astrounits.rad, location=el, obstime=t)
    ants = [ant.stand.earth_location for ant in antennas]
    ants = EarthLocation(x=astrounits.Quantity([ant.x for ant in ants]),
                         y=astrounits.Quantity([ant.y for ant in ants]),
                         z=astrounits.Quantity([ant.z for ant in ants]))
    
    
    # Coordinate transformation matrices
    site_p, site_v = el.get_gcrs_posvel(t)
    antpos_c_ap = GCRS(ants.get_gcrs_posvel(t)[0], 
                       obstime=t, obsgeoloc=site_p, obsgeovel=site_v)
    frame_uvw = ha.transform_to(antpos_c_ap)
    uvw_transform = rotation_matrix(0*astrounits.deg, 'x') \
                     @ rotation_matrix(-frame_uvw.spherical.lat, 'y') \
                     @ rotation_matrix(frame_uvw.spherical.lon, 'z')
    
    # Transform antennas into the (w,u,v) frame
    bl_ants = []
    for ant in antpos_c_ap:
        c = ant.cartesian
        bl_ants.append(uvw_transform @ np.array([c.x.to('m').value, c.y.to('m').value, c.z.to('m').value]))
        
    # Compute the baselines and convert to wavelengths
    for k,(i,j) in enumerate(baselines):
        bl = (bl_ants[i] - bl_ants[j])[[1,2,0]]
        bl.shape += (1,)
        
        uvw[k,:,:] = bl * freq.ravel() / speedOfLight
        
    uvw.shape = (Nbase,3)+freq.shape
    
    return uvw
